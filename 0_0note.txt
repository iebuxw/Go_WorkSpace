main函数必须在main包，同一个文件夹下不能有多个main包


代码组织
    go的项目是由包来组织的
    go的每一个文件要属于一个包，不能单独存在

垃圾回收：引入垃圾回收机制，内存自动回收，不需要开发人员管理
天然的支持高并发

打印：
    1、输出并换行：fmt.Println，打印多个会加空格
    2、Sprintf：格式化并返回变量
    2、Printf：格式化输出，不可以输出整形变量和整形
        %t：布尔值
        %q：如果是字符串会加引号，看得清楚
        %v      相应值的默认格式。            Printf("%v", people)   {zhangsan}，
        %+v     打印结构体时，会添加字段名     Printf("%+v", people)  {Name:zhangsan}
        %#v     相应值的Go语法表示            Printf("#v", people)   main.Human{Name:"zhangsan"}
        %T      相应值的类型的Go语法表示       Printf("%T", people)   main.Human
        %%      字面上的百分号，并非值的占位符  Printf("%%")            %

报错相关
	报错：no required module provides package hello.go: go.mod file not found in current directory or any parent directory; see 'go help modules'
	解决：go env -w GO111MODULE=auto

	go root：
	1、重装go到d盘
	2、加版本号 http://t.zoukankan.com/smartisn-p-15737839.html
	3、选择go sdk然后重启ide

注意事项
	当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，则为public，小写为protected
	注意： { 不能单独放在一行

	不需要分号

	var c int = 100
	// := 是声明并赋值，并且系统自动推断类型，不需要var关键字。:= 左侧的变量不应该是已经被声明过的，否则会导致编译错误
	d := 100

	指定变量类型，如果没有初始化，则变量默认为零值，而不是null

	Go 没有三目运算符

    声明了变量必须用，否则报错

    append(number2, 5): evaluated but not used       运算返回一个结果,但是没有赋给一个适当的变量

    go严格区分大小写

    var的用法：var identifier type
    make的用法：make(type, length, capacity)//capacity就是容量，警戒值

局部变量(函数内)：在函数体内声明的变量称之为局部变量
	//这种不带声明格式的(:=)只能在函数体中出现（也就是只能声明局部变量）
	//g, h := 123, "hello"

全局变量(函数外)：在函数体外声明的变量称之为全局变量，全局变量可以在任何函数中使用
	var (  // 这种因式分解关键字的写法一般用于声明全局变量
		a int
		b bool
	)
	var c = 111

数据类型

特殊运算符
	&	返回变量存储地址
	*	指针变量。

变量赋值
	var a string = "Runoob" //指定类型
	var v_name = value //自行判断类型
	intVal := 1 相当于：var intVal int; intVal =1 //使用:=

常量
    可以放main外面定义，也可以在main或者其他函数里定义
	const LENGTH = 10

	const (
		Unknown = 0
		Female = 1
		Male = 2
	)

if条件
	if 布尔表达式 {
	   /* 在布尔表达式为 true 时执行 */
	}

switch（默认情况下 case 最后自带 break 语句，所以不需要手动加）
	switch marks {
      case 90:
		grade = "A"
      case 80:
		grade = "B"
      case 50,60,70 :
		grade = "C"
      default:
		grade = "D"
   }

for循环
	sum := 0
	for i := 0; i <= 10; i++ {
		sum += i
	}

函数
	如果一组形参或返回值有相同的类型，我们不必为每个形参都写出参数类型，下面 2 个声明是等价的：
	func f(i, j, k int, s, t string) { /* ... */ }
	func f(i int, j int, k int, s string, t string) { /* ... */ }

	//返回单个
	func max(num1, num2 int) int {
	   return num1 + num2
	}

	//返回多个，其他语言不支持
	func swap(x, y string) (string, string) {
	   return y, x
	}

1.值类型:int系列、float系列、bool、string、数组和结构体
2.引用类型:指针、slice切片、map、管道chan、interface接口等   //引用类型如果用=，改变一个其他都改变

各int类型的取值范围为：
    int8: -128 ~ 127                                    (tinyint)
    int16: -32768 ~ 32767                               (smallint)
    int32: -2147483648 ~ 2147483647                     (int)
    int64: -9223372036854775808 ~ 9223372036854775807   (bigint)

字符串：
    字符串需要用双引号
    转义字符可以直接放双引号里
    字符串拼接用"+"
    单引号是 rune 类型，代表一个 UTF-8 字符，一般不用

数组：数组是具有相同唯一类型的一组已编号且长度固定的数据项序列。注意：1、类型要一样；2、长度固定（类似索引数组？）
	var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}

数组函数（Go 数组的长度不可改变）：append

二维数组
a := [3][4]int{
 {0, 1, 2, 3} ,   /*  第一行索引为 0 */
 {4, 5, 6, 7} ,   /*  第二行索引为 1 */
 {8, 9, 10, 11},   /* 第三行索引为 2 */
}

指针
	声明
	var ip *int        /* 指向整型*/
	var fp *float32    /* 指向浮点型 */

	使用
	ip = &a  /* 指针变量的存储地址 */
    fmt.Printf("*ip 变量的值: %d\n", *ip )   /* 使用指针访问值 */

	空指针判断：
	if(ptr != nil)     /* ptr 不是空指针 */
    if(ptr == nil)    /* ptr 是空指针 */

    //指针作为函数参数
    func test(x *int)  {
    	*x = 20
    }

结构体:Go 语言中数组可以存储同一类型的数据，但在结构体中我们可以为不同项定义不同的数据类型。1、固定数量；2、键不能数字；3、值类型可以不同(类似索引数组？)
	定义
	type struct_variable_type struct {
	   member definition
	   member definition
	   ...
	   member definition
	}

	变量的声明
	variable_name := structure_variable_type {value1, value2...valuen}
	或
	variable_name := structure_variable_type { key1: value1, key2: value2..., keyn: valuen}

	访问：结构体.成员名

语言切片（动态数组，可以扩充）
	var slice1 []type = make([]type, len, capacity)
	slice1 := make([]type, len, capacity)

	例如： var numbers = make([]int,3,5)    //理解：len 是数组的长度并且也是切片的初始长度，容量是是最大的长度
		   numbers := []int{0,1,2,3,4,5,6,7,8}
	切片截取：
	number2 := numbers[1:3]  /*  1(包含) 到索引 3(不包含) */
	number3 := numbers[:3]  /*  0(包含) 到索引 3(不包含) */
	number4 := numbers[3:]  /*  3(包含) 到索引上限为 len(s) */
	fmt.Println("number4 == ", number4)  //[3 4 5 6 7 8]

语言范围


语言Map(hash map)
    Map 是一种无序的键值对的集合。1、键、值分别统一类型；2、键值对；3、无序；4、动态扩充和删除

go没有继承概念

接口

并发

通道：goroutine之间的通信
     通道（channel）是用来传递数据的一个数据结构。
     管道的本质是队列，先进先出，最用是解决线程间通信
     要点:
        1、只能放指定数据类型
        2、放满了不能放
     锁：
        1、放满了没人取
        2、取时候是空的
        3、关闭的话读取是不会阻塞的

包的引入：
    1、方法名需要首字母大写，小写认为是private，引入不进来的
    2、貌似要放在$GO_PATH的src下，并且文件夹名、文件名、包名一致？
    3、引入时候按路径引入即可

编译可执行文件：go build -o bin\my.exe aaa\ddd\dccc\main
    1、编译命令要在$GO_PATH目录下执行
    2、编译是编译main包
    3、-o是换exe的路径、名称

go传参数启动服务
go run main.go -redis 192.168.99.233:6379

go加载第三方包：go mod tidy


类型转换
    1、type(v)
    2、str := strconv.Itoa(12)
    3、go中的类型判断则是判断一个变量是否属于某一种类型
        var a interface{} = 10
         _,isInt := a.(int) // 进行类型的断言的变量必须是空接口

类型断言：在Go语言中类型断言的语法格式如下: value,ok:=x.(T) 1 其中,x 表示一个接口的类型,T 表示一个具体的类型(也可为接口类型)。

//初始化
    var a int32
    var a string
    var a [5]int
    var a []int
    var a map[string] int
    var a Struct3
    var a *int
    var a chan int
    var a func(string) int


defer
defer是go中一种延迟调用机制，defer后面的函数只有在当前函数执行完毕后才能执行，通常用于释放资源
defer遵循先进后出的原则，类似于栈的结构。

GOROOT是指的Golang的安装目录
GOPATH是指的Golang的工作目录

代码的组织路径：
goWorkSpace     // goWorkSpace为GOPATH目录
  -- bin
     -- myApp1  // 编译生成
     -- myApp2  // 编译生成
  -- pkg
  -- src
     -- common 1
     -- common 2
     -- common utils ...
     -- myApp1     // project1
        -- models
        -- controllers
        -- others
        -- main.go
     -- myApp2     // project2
        -- models
        -- controllers
        -- others
        -- main.go

不同的项目可以设置不同的GO111MODULE，例如Go_WorkSpace项目使用的go path，gindemo使用的go mod

go mod的使用
	gopath是D:\go_code\，代码在D:\go_code\Go_WorkSpace，则在Go_WorkSpace目录下执行
	1、set GO111MODULE=on
	2、go mod init Go_WorkSpace
	3、编写配置文件
	4、go mod tidy //拉取缺少的模块，移除不用的模块。
	另：执行 go build main.go 或者 执行go get命令，拉取依赖库

go mod的禁用
	set GO111MODULE=off

go mode和go path会有冲突，用go path的时候需要禁用掉go mode，一般情况下，用go mod就好了

go path的使用
    1、set GO111MODULE=off
    2、在代码里import
    3、go get -t ... 代码里有提示，直接执行下就行
    4、go build main.go

go path的禁用
	set GO111MODULE=on
go mode和go path会有冲突，用go path的时候需要禁用掉go mode

数据类型转换：int64()直接转
    数字：
        1、无论是低精度到高精度都要强转
        2、高精度转到低精度，如果溢出不会报错，按溢出处理，取最大值
    字符串:
        1、用sprintf
        2、用strconv函数